---
layout: default
permalink: /sistemas/raspi.html
---

# Raspberry Pi

## Enlaces

### Varios

* [Gestión usuarios](http://www.raspberrypi.org/documentation/linux/usage/users.md)
* [IP Estática](http://www.electroensaimada.com/ip-estaacutetica.html)
* [Instalación cliente NO-IP](http://www.noip.com/support/knowledgebase/installing-the-linux-dynamic-update-client/)
* [Ultimate Raspberry Pi Configuration Guide](http://www.instructables.com/id/Ultimate-Raspberry-Pi-Configuration-Guide/?ALLSTEPS)
* [GitPi: A Private Git Server on Raspberry Pi](http://www.instructables.com/id/GitPi-A-Private-Git-Server-on-Raspberry-Pi/all/?lang=es)
* [PiKISS para Raspberry Pi](http://misapuntesde.com/post.php?id=409): Un puñado de scripts con menú para hacerte la vida más fácil
* [Java JDK para ARM](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-arm-downloads-2187472.html)
* [Cylon.js para Raspberry Pi](http://cylonjs.com/documentation/platforms/raspberry-pi/)
* [BerryBoot](http://www.berryterminal.com/doku.php/berryboot): Menú de arranque que permite arrancar varios sistemas instalados en la propia SD, en un disco duro/pendrive externo o en un almacenamiento en red (NAS).
* [An A to Z Beginners Guide to Installing RetroPie on a Raspberry Pi](http://supernintendopi.wordpress.com/)
* [How to install Oracle Java 8 in Debian via repository (JDK8)](http://www.webupd8.org/2014/03/how-to-install-oracle-java-8-in-debian.html)
* [Adafruit - Learn Raspberry Pi](https://learn.adafruit.com/category/learn-raspberry-pi)
* [Tutorials - The MagPi MagazineThe MagPi Magazine](https://www.raspberrypi.org/magpi/tutorials/)
* [Read-Only Raspberry Pi](https://learn.adafruit.com/read-only-raspberry-pi/)
* [Read-only Raspberry PI with Jessie](https://petr.io/en/blog/2015/11/09/read-only-raspberry-pi-with-jessie/)
* [Raspberry Pi Turnkey](https://github.com/schollz/raspberry-pi-turnkey): Sistema para gestionar la conexión a un punto de acceso cuando no hay posibilidad de conectar por SSH o consola (pantalla+teclado) para modificar el `wpa_supplicant`.
* [Imágenes berryboot](https://berryboot.alexgoldcheidt.com/images/)
* Imágenes Raspbian:
    * [Normal](https://downloads.raspberrypi.org/raspbian/images/)
    * [Lite](https://downloads.raspberrypi.org/raspbian_lite/images/)

### Distribuciones

* [Binary Emotions Slideshow](http://www.binaryemotions.com/digital-signage/raspberry-slideshow/): Slideshow de imágenes/vídeos.
* [Binary Emotions Digital Signage](http://www.binaryemotions.com/digital-signage/raspberry-digital-signage/): Slideshow de páginas web.
* [DietPi - Lightweight justice for your SBC](http://dietpi.com/)
* [Flint OS](https://flintos.io/): Versión de ChromeOS con soporte Android.
* [PiMAME](http://pimame.org/): Raspbian con un frontend para lanzar emuladores.
* [Lakka](http://www.lakka.tv/): Lakka is a lightweight Linux distribution that transforms a credit card sized computer into a full blown emulation console.
* [RetroPie](http://blog.petrockblock.com/retropie/)
* [batocera.linux](https://batocera-linux.xorhub.com/): Para construir Recalbox.

### Software

* [Pi-Hole](https://pax0r.com/bloquea-publicidad-molesta-con-pi-hole/): DNS que filtra dominios marcados por la comunidad como "molestos" y conseguiremos una navegación mas limpia y rápida.
* [PiVPN](http://www.pivpn.io/)

### Hardware

* [Lista de hardware verificado](http://elinux.org/RPi_VerifiedPeripherals)
* [Lista de compatibilidad de SDs](https://elinux.org/RPi_SD_cards)
* [Quick2Wire](http://Quick2Wire.com)
* [ESP8266 Serial Esp- 01](http://espressif.com/en/products/esp8266/): Módulo Wifi [por 2,25€](http://es.aliexpress.com/item/2PCS-ESP8266-Serial-Esp-01-WIFI-Wireless-Transceiver-Module-Send-Receive-LWIP-AP-STA/32232009463.html?recommendVersion=1) recomendado por [Fernando](https://twitter.com/m_trombone). [Listado de recursos](http://www.xess.com/blog/esp8266-resources/). Tutorial [conexión a Raspi](http://www.extragsm.com/blog/2014/12/03/connect-esp8266-to-raspberry-pi/).
* [TK2050 50W+50W Dual Channel Class T HIFI Stereo Audio Amplifier Board DC12V 24V](http://www.ebay.com/itm/TK2050-50W-50W-Dual-Channel-Class-T-HIFI-Stereo-Audio-Amplifier-Board-DC12V-24V-/181441180570): Recomendado por Fernando Oroquieta.
* [Using a Console Cable](https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable?view=all)
* [Adaptador Wifi (RTL8188CUS)](http://www.raspipc.es/public/home/index.php?ver=tienda&accion=verArticulo&idProducto=1079)
* [Adaptador TDT Conceptronic C08-096 (RTL2832)](http://www.amazon.es/Conceptronic-C08-096-receptor-Dvb-T-radio/dp/B003KCKERE)
* [Receptor infrarrojos](https://energenie4u.co.uk/catalogue/category/PiMote)
* [TP4056 DIY 1A Micro USB Li-Ion Battery Charging Board Charger Module](http://www.dx.com/p/tp4056-diy-1a-micro-usb-li-ion-battery-charging-board-charger-module-blue-373990): Cargador de batería.
* [PowerBoost 500 Charger - Rechargeable 5V Lipo USB Boost](http://www.adafruit.com/product/1944): Alimentación ininterrumpida con batería y gestor de carga.
* [UA0053 ADAPTADOR LOGILINK USB 2.0 AUDIO 5.1](http://www.cetronic.es/sqlcommerce/disenos/plantilla1/seccion/producto/DetalleProducto.jsp?idIdioma=&idTienda=93&codProducto=255195038&cPath=1295): Adaptador audio USB.
* [2-Channel 3W PAM8403 Audio Amplifier Board](http://www.dx.com/p/2-channel-3w-pam8403-audio-amplifier-board-red-146300): Amplificador audio 3W.
* [Stereo 2.8W Class D Audio Amplifier - I2C Control AGC](http://www.adafruit.com/product/1712): Amplificador audio 2.8W con control I2C.
* [Raspberry Pi Pinout](https://pinout.xyz/#): The comprehensive GPIO Pinout guide for the Raspberry Pi.

## Comandos útiles

### Comprobar asignaciones de cliente No-IP

Las asignaciones dejan marca en el log `syslog`:

```bash
edumoreno@raspi-git /var/log $ sudo fgrep noip syslog
Oct 16 12:18:57 raspi-git noip2[2165]: v2.1.9 daemon ended.
Oct 16 12:19:19 raspi-git noip2[2186]: v2.1.9 daemon started with NAT enabled
Oct 16 12:19:35 raspi-git noip2[2186]: eduardofilo.no-ip.biz set to 88.19.216.95
Oct 16 12:53:06 raspi-git noip2[2186]: v2.1.9 daemon ended.
Oct 16 13:15:23 raspi-git noip2[2217]: v2.1.9 daemon started with NAT enabled
Oct 16 13:15:25 raspi-git noip2[2217]: eduardofilo.no-ip.biz was already set to 88.19.216.95.
```

### Utilidad de configuración

```bash
$ sudo raspi-config
```

### Backup de la SD (comprimiendo al vuelo)

```bash
$ #Backup:
$ sudo dd if=/dev/mmcblk0 bs=2M status=progress | gzip -9 - > Rpi_8gb_backup.img.gz
$ #Backup sólo de 4GB (si por ejemplo la tarjeta es más grande pero no aprovecha toda la superficie)
$ sudo dd if=/dev/mmcblk0 bs=2M count=2048 | pv -s 4g | gzip -9 - > Rpi_4gb_backup.img.gz
$ #Restauración (comprimido con gzip):
$ gunzip Rpi_8gb_backup.img.gz -c | sudo dd of=/dev/mmcblk0 bs=2M status=progress conv=fsync
$ #Restauración (comprimido con xz):
$ xzcat Rpi_8gb_backup.img.xz | sudo dd of=/dev/mmcblk0 bs=2M status=progress conv=fsync
$ #Restauración (comprimido con zip):
$ unzip -p Rpi_8gb_backup.zip | sudo dd of=/dev/mmcblk0 bs=2M status=progress conv=fsync
$ #Restauración (comprimido con 7z):
$ 7z e -so Rpi_8gb_backup.7z | sudo dd of=/dev/mmcblk0 bs=2M status=progress conv=fsync
$ #Restauración (comprimido con rar):
$ rar p Rpi_8gb_backup.rar -idq | sudo dd of=/dev/mmcblk0 bs=2M status=progress conv=fsync
```

Para hacer un backup parcial los cálculos se harían así. Primero sacamos los datos de la estructura de la tarjeta con `fdisk`:

```bash
$ sudo fdisk -l /dev/mmcblk0
Disco /dev/mmcblk0: 14,4 GiB, 15502147584 bytes, 30277632 sectores
Unidades: sectores de 1 * 512 = 512 bytes
Tamaño de sector (lógico/físico): 512 bytes / 512 bytes
Tamaño de E/S (mínimo/óptimo): 512 bytes / 512 bytes
Tipo de etiqueta de disco: dos
Identificador del disco: 0xa125a0dc

Dispositivo    Inicio Comienzo    Final Sectores Tamaño Id Tipo
/dev/mmcblk0p1            8192    96663    88472  43,2M  c W95 FAT32 (LBA)
/dev/mmcblk0p2           98304 15550463 15452160   7,4G 83 Linux
```

Aquí vemos que cada sector ocupa 512 bytes. Nos fijamos en el último sector utilizado que en este caso es 15550463. Multiplicando este sector por el tamaño del sector (y sumando 1 al número de sectores por si empiezan a contar en 0) obtendremos el número de bytes que tendremos que copiar. Como el block size que vamos a utilizar es 2MB tendremos que truncar por lo alto (también servirá de medida de seguidad). Los cálculos en este caso resultarían:

    (15550463 + 1) (sector) * 512 (Byte/sector) / 1024 (Byte/KB) / 1024 (KB/MB) / 2 (MB/bloque) = 3796,5 bloques

Por tanto en este caso copiaremos 3797 bloques para cubrir esos 15550464 sectores.

### Backup de la SD (comprimiendo al vuelo con gzip y diviendo en trozos el fichero resultante)

```bash
$ #Backup:
$ sudo dd if=/dev/mmcblk0 bs=2M status=progress | gzip -9 - | split --bytes=2G - Rpi_8gb_backup.img.gz.part_
$ #Restauración:
$ cat Rpi_8gb_backup.img.gz.part_* | gunzip -c | sudo dd of=/dev/mmcblk0 bs=2M status=progress conv=fsync
```

### Backup de la SD (comprimiendo al vuelo con 7z y diviendo en trozos el fichero resultante)

```bash
$ #Backup:
$ sudo dd if=/dev/mmcblk0 bs=2M count=7350 status=progress | 7z -si -v1400m a Rpi_8gb_backup.img.7z
$ #Restauración:
$ 7z e -so Rpi_8gb_backup.7z.001 | sudo dd of=/dev/mmcblk0 bs=2M status=progress conv=fsync
```

### Backup de la SD (comprimiendo al vuelo con rar y diviendo en trozos el fichero resultante)

```bash
$ #Backup:
$ sudo dd if=/dev/mmcblk0 bs=2M count=7350 status=progress | rar a -m5 -sRpi_8gb_backup.img -v1400000k Rpi_8gb_backup.img.rar
$ #Restauración:
$ rar p Rpi_8gb_backup.img.part1.rar -idq | sudo dd of=/dev/mmcblk0 bs=2M status=progress conv=fsync
```

### Control de progreso durante flasheo

```bash
$ sudo pkill -USR1 -n -x dd
```

Como alternativa se puede instalar el comando `dcfldd` para sustituir a `dd`, con lo que obtendremos una indicación del progreso de la copia. `dcfldd` informa cada 256 bloques escritos por defecto. Para que lo haga con más frecuencia hay que pasarle la opción `statusinterval` de esta forma:

```bash
$ #Backup:
$ sudo dcfldd statusinterval=10 if=/dev/mmcblk0 bs=2M | gzip -9 - > Rpi_8gb_backup.img.gz
```

### Redimensionar particiones en imagen

Fuente: Apartado **Resizing a partition within an image file** en [Shrinking Raspberry Pi SD Card Images](http://www.aoakley.com/articles/2015-10-09-resizing-sd-images.php).

1. Obtenemos los parámetros de las particiones de la imagen:

    ```
    $ sudo fdisk -l Octoprint_niubit.img
    Disco Octoprint_niubit.img: 7,5 GiB, 8010072064 bytes, 15644672 sectores
    Unidades: sectores de 1 * 512 = 512 bytes
    Tamaño de sector (lógico/físico): 512 bytes / 512 bytes
    Tamaño de E/S (mínimo/óptimo): 512 bytes / 512 bytes
    Tipo de etiqueta de disco: dos
    Identificador del disco: 0x15f1d664

    Dispositivo           Inicio Comienzo    Final Sectores Tamaño Id Tipo
    Octoprint_niubit.img1            8192    98045    89854  43,9M  c W95 FAT32 (LBA)
    Octoprint_niubit.img2           98304 15644671 15546368   7,4G 83 Linux
    ```

2. Localizamos el primer dispositivo loop libre:

    ```
    $ ls -l /dev/loop*
    ```

3. Conectamos la partición que queremos redimensionar con el primer dispositivo loop libre aplicando un offset en base al sector de comienzo de la partición que queremos encoger (`98304` en este ejemplo):

    ```
    $ sudo losetup /dev/loop12 Octoprint_niubit.img -o $((98304*512))
    ```

4. Montamos la partición en el sistema de archivos para hacer limpieza (por ejemplo `/var/cache/apt/archives`) y desmontamos al final.
5. Editamos la partición con `gparted` y la encogemos todo lo posible:

    ```
    $ sudo gparted /dev/loop12
    ```

6. Aunque hemos encogido la partición, en la tabla de asignación de la imagen continuará con el antiguo tamaño, motivo por el que `gparted` muestra un icono de aviso. Lo solucionaremos a continuación. Tomamos nota del tamaño final en KB que se ha dado a la partición fijándonos en el comando `resize2fs` que `gparted` ha ejecutado mirando los detalles al finalizar la operación anterior. Por ejemplo:

    ```
    resize2fs -p '/dev/loop12' 3250176K
    ```

7. Eliminar el dispositivo loop que hemos estado utilizando:

    ```
    $ sudo losetup -d /dev/loop12
    ```

8. Conectar ahora la imagen completa de nuevo al dispositivo loop:

    ```
    $ sudo losetup /dev/loop12 Octoprint_niubit.img
    ```

9. Editamos con `fdisk` la imagen:

    ```
    sudo fdisk /dev/loop12
    ```

10. Borramos la partición que hemos redimensionado pulsando `d 2`.
11. Creamos de nuevo la partición pulsando `n p 2`. Nos pedirá el primer sector. Introduciremos el obtenido en el paso 1 (`98304` en este ejemplo). A continuación nos pedirá el tamaño. Introduciremos el obtenido en el paso 6 con un `+` delante (`+3250176K` en este ejemplo). Si nos pregunta en ese momento `¿Desea eliminar la firma?` respondemos `No`. Finalmente pulsamos `w` para registrar los cambios.
12. Volvemos a obtener los parámetros de las particiones de la imagen:

    ```
    $ sudo fdisk -l Octoprint_niubit.img
    Disco Octoprint_niubit.img: 7,5 GiB, 8010072064 bytes, 15644672 sectores
    Unidades: sectores de 1 * 512 = 512 bytes
    Tamaño de sector (lógico/físico): 512 bytes / 512 bytes
    Tamaño de E/S (mínimo/óptimo): 512 bytes / 512 bytes
    Tipo de etiqueta de disco: dos
    Identificador del disco: 0x15f1d664

    Dispositivo           Inicio Comienzo   Final Sectores Tamaño Id Tipo
    Octoprint_niubit.img1            8192   98045    89854  43,9M  c W95 FAT32 (LBA)
    Octoprint_niubit.img2           98304 6598655  6500352   3,1G 83 Linux
    ```

13. Tomamos nota del sector final de la segunda partición (`6598655` en este ejemplo).
14. Eliminamos el dispositivo loop que hemos utilizado:

    ```
    $ sudo losetup -d /dev/loop12
    ```

15. Truncamos la imagen para retirar la parte que ya no está cubierta por la partición que hemos encogido:

    ```
    $ truncate -s $(((6598655+1)*512)) Octoprint_niubit.img
    ```

16. Ya habríamos terminado, pero todavía se puede mejorar la imagen rellenando con ceros los sectores no utilizados. Para ello proceder como sigue (sustituyendo el sector de comienzo `98304` del ejemplo por el que corresponda):

    ```
    $ sudo losetup /dev/loop12 Octoprint_niubit.img -o $((98304*512))
    $ sudo mkdir -p /mnt/imageroot
    $ sudo mount /dev/loop12 /mnt/imageroot
    $ sudo dd if=/dev/zero of=/mnt/imageroot/zero.txt status=progress
    $ sudo rm /mnt/imageroot/zero.txt
    $ sudo umount /mnt/imageroot
    $ sudo rmdir /mnt/imageroot
    $ sudo losetup -d /dev/loop12
    ```

Ya tenemos lista la imagen para poderla flashear sobre tarjetas. Si la comprimimos con `gzip` se comprimirá mejor si hemos realizado el paso final.

Existen estas dos utilidades para automatizar este proceso:

* [PiShrink](https://github.com/Drewsif/PiShrink)
* [cotswoldjam](https://github.com/aoakley/cotswoldjam)

### Gestión de la SWAP

Para redimensionar la Swap predeterminada (fichero de 100MB en `/var/swap`):

```bash
$ sudo nano /etc/dphys-swapfile
$ sudo dphys-swapfile setup
$ sudo dphys-swapfile swapon
```

Para consultar el estado de la swap:

```bash
$ swapon -s
```

Para dejar de usar swap:

```bash
$ sudo swapoff -a
```

Para activar la swap tal y como está definida en ''/etc/fstab'':

```bash
$ sudo swapon -a
```

Para activar swap con un fichero en concreto:

```bash
$ sudo swapon /var/swap
```

### Escaneo de Raspberry Pi's en red

```bash
$ arp -a | grep b8:27:eb
$ sudo nmap -PR -sP 192.168.1.0/24 | fgrep -B 2 "Raspberry"
```

## Pulsador encendido/apagado

Existe una configuración accesible mediante un [Device Tree overlay](https://github.com/raspberrypi/firmware/blob/master/boot/overlays/README) que permite arrancar y parar el sistema controladamente con un pulsador entre los pines #5 (GPIO03 o SCL) y GND. Para que funcione hay que añadir lo siguiente al fichero `/boot/config.txt`:

```
dtoverlay=gpio-shutdown
```

[Aquí](https://www.stderr.nl/Blog/Hardware/RaspberryPi/PowerButton.html) se documenta en profundidad.

## Pi-top

### Enlaces

* [pi-top-install](https://github.com/rricharz/pi-top-install): Scripts para controlar el hardware del Pi-top (teclas brillo pantalla, power off, etc.) sobre Raspbian oficial.
* [pi-top-battery-status](https://github.com/rricharz/pi-top-battery-status): Muestra el estado de la batería del Pi-top en Raspbian.
* [Pi-Top battery firmware / battery issues](https://www.riscosopen.org/forum/forums/5/topics/8989)

## Artículos interesantes de [TheMagPi](http://www.themagpi.com/)

* Librería Python para controlar un puerto USB: Página 14 de #3 de TheMagPi
* Buffer de dispositivos controlados con el GPIO de RPi: Página 19 de #4 de TheMagPi
* Librería wiringPi: Sirve para comandar y leer el GPIO desde bash. Página 14 de #6 de TheMagPi
* Comunicación entre RaspPi y Arduino: Página 4 de #7 de TheMagPi
* Uso de interrupciones para chequear GPIO sin bucles: Página 12 de #7 de TheMagPi
* Librería Nanpy para comunicar RaspPi y Arduino por USB: Página 10 de #8 de TheMagPi
* WebIOPi - Framework REST para controlar el GPIO: Página 8 de #9 de TheMagPi

## Ajustes primer arranque

### Configuración headless

#### Activación de SSH

Crear un fichero vacío con nombre `ssh` en partición boot.

#### Conexión a punto de acceso Wifi

Crear un fichero con nombre `wpa_supplicant.conf` en partición boot con el siguiente contenido:

```
country=ES
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid="<el_ssid>"
    psk="<el_pwd>"
    key_mgmt=WPA-PSK
}
```

#### IP estática

Primero averiguamos el nombre del interfaz al que queremos poner la IP estática consultando `ifconfig`. Luego editamos `/etc/dhcpcd.conf` y al final añadimos:

```
interface <nombre_interfaz>
static ip_address=<ip>/24
static routers=<gateway>
static domain_name_servers=<dns separadas por espacios>
```

### raspi-config

* Network Options > Hostname
* Boot Options > Wait for Network at Boot
* Localisation Options > Change Locale
* Localisation Options > Change Timezone

### Ajustes usuario

* Crear una nueva cuenta:

    ```bash
    $ sudo adduser usuario
    $ sudo adduser usuario adm
    $ sudo adduser usuario dialout
    $ sudo adduser usuario cdrom
    $ sudo adduser usuario sudo
    $ sudo adduser usuario audio
    $ sudo adduser usuario video
    $ sudo adduser usuario plugdev
    $ sudo adduser usuario games
    $ sudo adduser usuario users
    $ sudo adduser usuario input
    $ sudo adduser usuario netdev
    $ sudo adduser usuario gpio
    $ sudo adduser usuario i2c
    $ sudo adduser usuario spi
    ```

* Cambiar UID de usuario edumoreno para que coincida con el del NAS:

    ```bash
    sudo usermod -u 1002 usuario
    ```

* Borrar la cuenta `pi` desde la nueva:

    ```bash
    $ sudo deluser -remove-home pi
    ```

* Copia de clave pública para SSH automático (desde máquina host):

    ```bash
    $ ssh-copy-id -i ~/.ssh/id_rsa.pub usuario@IP_RASPBERRY
    ```

### Instalación de paquetes

* Instalar paquetes:
    * `fail2ban`
    * `nfs-common`
    * `transmission-daemon`
    * `amule-daemon`
* Desinstalar paquete `wolfram-engine` que ocupa mucho y no se suele usar (en la versión lite no viene).

### Montaje NAS

Añadir lo siguiente a `/etc/fstab`:

    192.168.1.200:/c/carpeta_compartida /home/usuario/carpeta_compartida nfs4 defaults,user,exec 0 0

### SSH

Editar el fichero `/etc/ssh/sshd_config` y modificar/añadir las siguientes líneas ([fuente](http://blog.zoogon.net/2013/01/protegiendo-un-poco-nuestra-raspberry.html)):

```
PermitRootLogin no
MaxAuthTries 3
MaxStartups 5
AllowUsers edumoreno
```

Medidas de protección:

* [Top 20 OpenSSH Server Best Security Practices](http://www.cyberciti.biz/tips/linux-unix-bsd-openssh-server-best-practices.html)
* [Protege tu servidor casero de ataques externos](http://blog.desdelinux.net/protege-tu-servidor-casero-de-ataques-externos/)
* [Protegiendo el servidor SSH con fail2ban](http://blog.zoogon.net/2015/02/protegiendo-el-servidor-ssh-con-fail2ban.html)
* [Pasos para asegurar tu Raspberry Pi frente a posibles amenazas](https://www.redeszone.net/2017/09/14/pasos-asegurar-raspberry-pi-frente-posibles-amenazas/)

## Raspad

### Enlaces

* SunFounder Wiki

    * [Replace HDMI cable tutorial](http://wiki.sunfounder.cc/index.php?title=Replace_HDMI_cable_tutorial)
    * [Replace power USB cable tutorial](http://wiki.sunfounder.cc/index.php?title=Replace_power_USB_cable_tutorial)
    * [The touch screen does not work properly FAQ](http://wiki.sunfounder.cc/index.php?title=The_touch_screen_does_not_work_properly_FAQ)
    * [Install the fan for Raspad](http://wiki.sunfounder.cc/index.php?title=Install_the_fan_for_Raspad): [STL's alternativos](https://www.thingiverse.com/thing:3074407).

* Instalación de Android

    * [Install Android on his Raspberry Pi](https://howtoraspberrypi.com/install-android-raspberry-pi/)

* Calibración de pantalla

    * [https://www.facebook.com/groups/192987478051513/permalink/233950007288593/](https://www.facebook.com/groups/192987478051513/permalink/233950007288593/)

* Clic derecho

    * [Raspberry Ri Touch Screen setup right click with twofing – Raspbian Jessie](https://maker-tutorials.com/en/raspberry-ri-touch-screen-setup-right-click-with-twofing/)

### Configuración

#### Sistema base

[Raspbian](https://downloads.raspberrypi.org/raspbian_latest)

#### Digitalizador de pantalla

El equipo recién instalado lleva un firmware bastante deficiente en el digitalizador táctil de la pantalla. Hay que actualizarlo siguiendo los pasos del siguiente artículo del wiki de SunFounder: [The touch screen does not work properly FAQ](http://wiki.sunfounder.cc/index.php?title=The_touch_screen_does_not_work_properly_FAQ)

#### Teclado en pantalla

Instalar el paquete: `matchbox-keyboard`

#### Clic secundario

Para conseguir emular el clic derecho del ratón procedemos como sigue (fuentes: [1](https://maker-tutorials.com/en/raspberry-ri-touch-screen-setup-right-click-with-twofing/) y [2](https://www.diskiopi.com/forum/viewtopic.php?id=30)):

1. Instalamos los siguientes paquetes:
    ``` bash
    $ sudo apt-get update && sudo apt-get install build-essential libx11-dev libxtst-dev libxi-dev x11proto-randr-dev libxrandr-dev xserver-xorg-input-evdev xinput-calibrator
    ```
2. Descargamos el código de twofing y lo extraemos:
    ``` bash
    $ wget http://plippo.de/dwl/twofing/twofing-0.1.2.tar.gz
    $ tar -xvzf twofing-0.1.2.tar.gz
    $ cd twofing-0.1.2
    ```
3. Compilamos:
    ``` bash
    $ make && sudo make install
    ```
4. Creamos el fichero `/etc/udev/rules.d/70-touchscreen-ilitek.rules` con el siguiente contenido:
    ```
    SUBSYSTEMS=="usb",ACTION=="add",KERNEL=="event*",ATTRS{idVendor}=="222a",ATTRS{idProduct}=="0001",SYMLINK+="twofingtouch",RUN+="/bin/chmod a+r /dev/twofingtouch"
    KERNEL=="event*",ATTRS{name}=="ILITEK Multi-Touch-V3000",SYMLINK+="twofingtouch",RUN+="/bin/chmod a+r /dev/twofingtouch"
    ```
5. Creamos el fichero `/usr/share/X11/xorg.conf.d/90-touchinput.conf` con el siguiente contenido:
    ```
    Section "InputClass"
    Identifier "calibration"
    Driver "evdev"
    MatchProduct "ILITEK ILITEK-TP"
    MatchDevicePath "/dev/input/event*"
    Option "Emulate3Buttons" "True"
    Option "EmulateThirdButton" "1"
    Option "EmulateThirdButtonTimeout" "750"
    Option "EmulateThirdButtonMoveThreshold" "30"
    EndSection
    ```
6. Creamos el fichero `/etc/udev/rules.d/ 99-input-tagging.rules` con el siguiente contenido:
    ```
    ACTION=="add", KERNEL=="event*", SUBSYSTEM=="input", TAG+="systemd", , ENV{SYSTEMD_ALIAS}+="/sys/subsystem/input/devices/$env{ID_SERIAL}"
    ```
7. Creamos el fichero `~/.config/autostart/twofing.desktop` con el siguiente contenido:
    ```
    [Desktop Entry]
    Type=Application
    Name=Twofing
    Exec=twofing
    StartupNotify=false
    ```
## Raspi Camera

La documentación de la librería picamera en Python está [aquí](https://picamera.readthedocs.io/en/release-1.10/index.html). Concretamente las recetas para hacer la foto están [aquí](https://picamera.readthedocs.io/en/release-1.10/recipes1.html).

Por ejemplo, para hacer fotos que luego vayan a formar parte de un timelapse:

``` python
import time
import picamera
import datetime as dt

with picamera.PiCamera() as camera:
    camera.resolution = (1280, 720)
    camera.framerate = 30
    # calentamiento/enfoque de la camara
    time.sleep(2)
    # fijamos valores para que salga mejor el timelapse
    camera.shutter_speed = camera.exposure_speed
    camera.exposure_mode = 'off'
    g = camera.awb_gains
    camera.awb_mode = 'off'
    camera.awb_gains = g
    camera.annotate_background = picamera.Color('black')
    camera.annotate_text = dt.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    filename = time.strftime("%Y-%m-%d_%H%M.jpg")
    camera.capture(filename)
```

## Activar consola en puerto serie

Las Raspberry Pi Zero W, Pi 3 y Pi 4 traen un adaptador Bluetooth que en Raspbian está conectado precisamente a los pines #08 y #10 donde tradicionalmente se encontraba el puerto serie. En [este documento](https://www.raspberrypi.org/documentation/configuration/uart.md) se explican los cambios en estas versiones. En [este otro artículo](https://raspberrypi.stackexchange.com/a/54766) se dan opciones para modificar este comportamiento. Lo que sigue es una versión personal.

Para liberar esta conexión debemos editar el fichero `config.txt` que hay en la partición boot y añadir (al final por ejemplo) lo siguiente:

```
dtoverlay=pi3-disable-bt
```

Esto podemos hacerlo sin necesidad de arrancar el sistema, montando la microSD en el ordenador. Para el siguiente paso sí necesitamos arrancar el sistema de la tarjeta en la Raspberry. Una vez estemos en la consola (por SSH o conectando una pantalla/teclado/ratón de alguna manera), ejecutaremos:

sudo raspi-config

Allí acudiremos a la sección Interfacing options > Serial y responderemos de la siguiente forma a las dos preguntas que nos hará:

    Would you like a login shell to be accessible over serial? -> Yes
    Would you like the serial port hardware to be enabled? -> Yes

Reiniciaremos y ya podremos conectar a la consola a través del puerto serie.

## Crankshaft

### Actualización distribución

1. Descargar la última versión de la [página de descarga](https://github.com/opencardev/crankshaft/releases).
2. Copiar el zip o mejor el contenido (.img y .md5) a la raíz de un pendrive con formato FAT32.
3. Conectar el pendrive a la Raspberry antes de arrancar.
4. El proceso de actualización (descrito en [esta página](https://github.com/opencardev/crankshaft/wiki/Installing-and-Updating#upgrade-via-usb-stick)) es lento y requiere varios reinicios. Esperar pues hasta terminar de ver el sistema correctamente arrancado.
5. Instalar el script del Mausberry Car Switch:

    1. Copiar el siguiente script en la ruta `/etc/switch.sh`:

        ```bash
        #!/bin/bash

        #this is the GPIO pin connected to the lead on switch labeled OUT
        GPIOpin1=23

        #this is the GPIO pin connected to the lead on switch labeled IN
        GPIOpin2=24

        #Enter the shutdown delay in minutes
        delay=0

        echo "$GPIOpin1" > /sys/class/gpio/export
        echo "in" > /sys/class/gpio/gpio$GPIOpin1/direction
        echo "$GPIOpin2" > /sys/class/gpio/export
        echo "out" > /sys/class/gpio/gpio$GPIOpin2/direction
        echo "1" > /sys/class/gpio/gpio$GPIOpin2/value
        let minute=$delay*60
        SD=0
        SS=0
        SS2=0
        while [ 1 = 1 ]; do
        power=$(cat /sys/class/gpio/gpio$GPIOpin1/value)
        uptime=$(</proc/uptime)
        uptime=${uptime%%.*}
        current=$uptime
        if [ $power = 1 ] && [ $SD = 0 ]
        then
        SD=1
        SS=${uptime%%.*}
        fi

        if [ $power = 1 ] && [ $SD = 1 ]
        then
        SS2=${uptime%%.*}
        fi

        if [ "$((uptime - SS))" -gt "$minute" ] && [ $SD = 1 ] && [ $power = 1 ]
        then
        poweroff
        SD=3
        fi

        if [ "$((uptime - SS2))" -gt 20 ] && [ $SD = 1 ]
        then
        SD=0
        fi

        sleep 1
        done
        ```

    2. Darle permisos de ejecución.
    3. Añadir lo siguiente al final del fichero `/etc/rc.local` (justo antes del `exit 0`) para que se ejecute en el arranque:

        ```
        /etc/switch.sh &
        ```
